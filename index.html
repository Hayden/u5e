<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>u5e: u5e</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">u5e
   </div>
   <div id="projectbrief">UnicodeTextC++Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceu5e.html" title="main u5e namespace ">u5e</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Unicode Text C++ library &ndash; fork me on github: <a href="https://github.com/ruoso/u5e">https://github.com/ruoso/u5e</a></p>
<h1>What is this library?</h1>
<p>This library provides support for Unicode Text, as specified by the Unicode Standard.</p>
<p>These are the problems that this library intends to solve (links for examples):</p>
<ul>
<li>Iterating and truncating on correct boundaries for:<ul>
<li>codepoints - <a href="simple_iteration.html">iterate</a>, <a href="smallest_code.html">over const char*</a>, <a href="truncate_on_codepoint.html">truncate</a>.</li>
<li>graphemes - <a href="grapheme_iteration.html">iterate</a>, <a href="truncate_on_grapheme.html">truncate</a>.</li>
<li>words</li>
<li>sentences</li>
</ul>
</li>
<li>Normalization<ul>
<li>Normalization Form D - <a href="normalization_form_d.html">in utf8</a>, <a href="normalization_form_d_utf32.html">in utf32</a></li>
<li>Normalization Form C - <a href="normalization_form_c.html">in utf8</a>, <a href="normalization_form_c_utf32.html">in utf32</a></li>
<li>Normalization Form KD - <a href="normalization_form_kd.html">in utf8</a>, <a href="normalization_form_kd_utf32.html">in utf32</a></li>
<li>Normalization Form KC - <a href="normalization_form_kc.html">in utf8</a>, <a href="normalization_form_kc_utf32.html">in utf32</a></li>
</ul>
</li>
<li>Explicitly Localized and Explicitly Non-localized support for:<ul>
<li>Comparison</li>
<li>Sorting</li>
<li>Case Folding</li>
<li>Search Folding (folded to 'base character')</li>
<li>Tokenizing</li>
</ul>
</li>
</ul>
<h1>Why?</h1>
<p>Properly supporting international text is one of these problems that you either think is very easy because you never had to deal with internationalized text, or you give up on it because you think no one can support Unicode correctly. This library is an attempt to provide a simple reusable set of interfaces to deal with international text.</p>
<h1>Why not just use the icu library?</h1>
<p>The first reason for me to consider this was that the icu library is much more complex than what's required for supporting text. ICU also supports the full localization definitions of the Unicode CLDR, which makes its support surface much larger than would be required for simply handling text.</p>
<p>Secondly, the icu library forces the internal representation of the text to always be in a particular encoding (UTF16). I believe that this is an unecessary constraint, and one of the points of this library is to make the encoding pluggable without requiring different APIs or explicit conversions.</p>
<h1>Some important conversations</h1>
<h2>A note on dynamic encodings</h2>
<p>While it is technically possible to operate on text with a dynamically assigned encoding, I honestly believe the use case for that is more academic than anything else.</p>
<p>Your application should have one internal encoding and all text should be converted on the borders of the application to whatever makes the most sense for your application.</p>
<p>For instance, if you're dealing with mostly 7-bit ASCII text with the ocasional exception (such as most latin languages), UTF8 is definitely the most efficient usage of memory, and will promote the best cache locality.</p>
<p>If, on the other hand, the application is expected to deal with mostly non-latin text, UTF16 is believed to result in the smallest memory usage.</p>
<p>But if you don't quite care about memory usage and you have a stronger requirement for being able to do more efficient random access on the text, UTF32 with native endianess will make the most sense.</p>
<p>It is, of course, technically feasible to have encodings that make decisions at run time, but the cost of that runtime decision will be paid over and over in the life-cycle of that object.</p>
<p>For that reason, it is much more intelligent to convert the text to one of UTF8, UTF16 with native endianess or UTF32 with native endianess at the border of your application. I cannot see a rason to support any other encoding as the basis for operating on the text, any other encoding may be considered a serialization format to be converted to and from in the borders of your application.</p>
<p>Note that since the encoding is pluggable, it would be possible for a third-party to contribute support for dynamic encodings.</p>
<h2>A note on endianess</h2>
<p>The unicode standard defines UTF16BE and UTF16LE, as well as UTF32BE and UTF32LE. The bare "UTF16" and "UTF32" encodings are actually runtime-defined according to Byte-Order-Marker (BOM), the default, in the absense of a BOM is Big-Endian, accorting to the standard &ndash; utf8 is always little endian, and BOM characters in utf8 are not relevant.</p>
<p>This library introduces the terms UTF16NE and UTF32NE. Those are not encodings, but rather architecture-specific runtime types that will either be the BE or the LE variants depending on the machine that runs it. Whenever you are using the UTF16NE and UTF32NE types, you are expected to appropriately convert the incoming texts to the correct native encoding on the borders of your application.</p>
<h2>A note on legacy encodings</h2>
<p>This library will not support converting to and from legacy encodings as well as operating on them. You are expected to perform the convertions at the borders of your application.</p>
<p>Note that since the encoding is pluggable, it would be possible for a third-party to contribute support for native encodings.</p>
<h2>A note on bound checks</h2>
<p>UTF8 and UTF16 introduce a new possible type of overflow and underflow. If you are trying to iterate forward, the first octet in UTF8 &ndash; or the first 16bit in UTF16 &ndash; may tell you to look for more characters than what fits in the rest of the buffer. Likewise, if you're iterating backwards, the first octet of your utf8 text &ndash; or 16bits in utf16 &ndash; may tell you that you need to look further back, underflowing the buffer.</p>
<p>There are two possible ways to handle this, the first is to make the bounds check pervasively in the code. This means that the entire API needs to be more complicated because every operation now needs to know where the string ends, not to mention that the additional checks will have a compounding runtime cost.</p>
<p>The alternative, which is what this library implements, is to validate the strings in the borders of your application, whenever you receive a text from the outside, you need to check for correctness on the start and end of your text.</p>
<p>This library will offer a utility function to verify the correctness of the string, and optionally forcing the replacement of the invalid utf8 and utf16 sequences by replacement characters.</p>
<h1>This library will not cover</h1>
<p>These are the problems that are explicitly outside of the scope of this library. They can, and most likely should, be solved in libraries built on top of <a class="el" href="namespaceu5e.html" title="main u5e namespace ">u5e</a>.</p>
<ul>
<li>Rendering</li>
<li>Font sizes</li>
<li>Word wrapping</li>
<li>Text presentation order (LTR vs RTL)</li>
<li>Number and Date formatting and parsing</li>
<li>Regular Expressions</li>
<li>Streaming, specifically partial reads and writes</li>
</ul>
<h1>What are the guiding principles?</h1>
<h2>No "natural" unit</h2>
<p>There is no default unit. Most of the confusion around unicode is derived from the misconceptions on how to iterate over text and how to count and measure it. This libray defines and uses the following units:</p>
<ol type="1">
<li>native size: This measure the size of the text in its in-memory representation. It is not necessarily a number of bytes, but it's rather a variable size depending on the encoding and on the architecture where the code is running: for instance, UTF8 always uses octets as the encoding unit, however UTF32 may either use a 32 bit int, if the endianess is the same, or it may still be forced to use octets if it's the wrong endianess. The size in bytes is an implementation detail that is architecture-specific and can be measured using operators like sizeof().</li>
<li>codepoint: The unicode standard calls this "character", but the oveloading of this term is definitely one of the main sources of confusion around the unicode standard, therefore, in this library we just do not ever use the term "character", and prefer the more precise term "codepoint", which represents an encoded unicode entity, which is usually represented as U+DEADBEEF.</li>
<li>grapheme: The grapheme is the unit of rendering, also referenced in the standard as "grapheme cluster" or "user perceived
   character". It represents a sequence of one or more codepoints that represent a single graphical symbol, previous versions of the unicode standard had a simple rule of "base character" and "combining characters", but more recent versions of the standard support more complex definitions for grapheme cluster boundaries.</li>
<li>word: A word is a set of graphemes that form a unit, it can be as simple as "two words" for english, but it requires the use of the unicode database for full internationalization support.</li>
<li>sentence: A collection of words. There is a property of codepoints in the unicode database that specifies if a given character is a sentence separator or not.</li>
</ol>
<h2>Handling of text requires intermediate buffers</h2>
<p>There is no sane way to handle text directly on streams, see <a class="el" href="md__home_ruoso_devel_u5e_StreamVsIterators.html">Streams versus Iterators</a> for a longer discussion.</p>
<h2>Number and Date format is outside of the scope</h2>
<p>The coupling of number and date format to streams is a major source of ambiguity in the standard library, see <a class="el" href="md__home_ruoso_devel_u5e_StreamVsFormat.html">Streams versus Format</a> for a longer discussion.</p>
<h1>The different aspects of Text</h1>
<p>In order to allow maximum reusability of the code, each aspect of the text is going to be expressed in this library as a concept. Different traits will implement that concept in different ways in order to at the same time allow room for optimizations. For instance, UTF32 with native endianess will be able to use the native integer type, while UTF32 with the foreign endianess will need to use four octets and will need to do the byte-swapping at runtime for most operations.</p>
<p>The usage of traits for this also gives us transparent type-safety. Such that we can statically evaluate if you are incorrectly mixing texts of different encodings, which is the most common form of mistake when handling internationalized text.</p>
<h2>Encoding</h2>
<p>The encoding concept will provide that basic interface from the in-memory representation to iteration and access of codepoints.</p>
<h2>Normalization Form</h2>
<p>Normalization is what allows equivalent sequences of characters to be treated as being the same. By making the normalization a trait of the text, we allow the implicit re-normalization when dealing with denormalized text, at te same time that it gives room for important optimizations when two different texts have the same normalization form.</p>
<h2>Locale tailoring</h2>
<p>The unicode standard has several features that are coupled with the tailoring to specific locales, this will also be applicable to different features. Making this into a trait allows to selectively disable the tailoring for application where the speed gain from not supporting this is more important than the use cases where such support is a requirement. Making this into a trait even allows optimizing away the storage required for storing the language of the text, or if an application needs optimization for the tailoring for a single language, it could be implemented directly as code and avoid any runtime language queries. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
