<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>u5e: u5e Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">u5e
   </div>
   <div id="projectbrief">UnicodeTextC++Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">u5e Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>main <a class="el" href="namespaceu5e.html" title="main u5e namespace ">u5e</a> namespace  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceu5e_1_1props"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e_1_1props.html">props</a></td></tr>
<tr class="memdesc:namespaceu5e_1_1props"><td class="mdescLeft">&#160;</td><td class="mdescRight">codepoint property handling <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceu5e_1_1version"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e_1_1version.html">version</a></td></tr>
<tr class="memdesc:namespaceu5e_1_1version"><td class="mdescLeft">&#160;</td><td class="mdescRight">introspection over the vesion of the library both at compile time and at runtime. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1basic__encodedstring.html">basic_encodedstring</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">basic encoding support over string-like objects.  <a href="classu5e_1_1basic__encodedstring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a single grapheme cluster.  <a href="classu5e_1_1basic__grapheme.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1basic__grapheme__iterator.html">basic_grapheme_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator that describes full graphemes.  <a href="classu5e_1_1basic__grapheme__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1codepoint.html">codepoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native representation of a codepoint.  <a href="classu5e_1_1codepoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1codepoint__traits.html">codepoint_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for codepoint.  <a href="classu5e_1_1codepoint__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1encoding__assertion.html">encoding_assertion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert the encoding matches the native type.  <a href="classu5e_1_1encoding__assertion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1iterator__assertion.html">iterator_assertion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts the iterator is consistently defined.  <a href="classu5e_1_1iterator__assertion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf32ne.html">utf32ne</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Architecture-specific type to interface UTF32BE or UTF32LE.  <a href="classu5e_1_1utf32ne.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf32ne__string.html">utf32ne_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__encodedstring.html" title="basic encoding support over string-like objects. ">basic_encodedstring</a> of <a class="el" href="classu5e_1_1utf32ne.html" title="Architecture-specific type to interface UTF32BE or UTF32LE. ">utf32ne</a> and std::basic_string&lt;int&gt;  <a href="classu5e_1_1utf32ne__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf32ne__string__grapheme.html">utf32ne_string_grapheme</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__grapheme.html" title="Represents a single grapheme cluster. ">basic_grapheme</a> of <a class="el" href="classu5e_1_1utf32ne__string.html" title="Typedef: basic_encodedstring of utf32ne and std::basic_string&lt;int&gt; ">utf32ne_string</a>.  <a href="classu5e_1_1utf32ne__string__grapheme.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf32ne__string__grapheme__iterator.html">utf32ne_string_grapheme_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__grapheme__iterator.html" title="Iterator that describes full graphemes. ">basic_grapheme_iterator</a> of <a class="el" href="classu5e_1_1utf32ne__string.html" title="Typedef: basic_encodedstring of utf32ne and std::basic_string&lt;int&gt; ">utf32ne_string</a>.  <a href="classu5e_1_1utf32ne__string__grapheme__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf32ne__string__view.html">utf32ne_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__encodedstring.html" title="basic encoding support over string-like objects. ">basic_encodedstring</a> of <a class="el" href="classu5e_1_1utf32ne.html" title="Architecture-specific type to interface UTF32BE or UTF32LE. ">utf32ne</a> and basic_string_view&lt;int&gt;  <a href="classu5e_1_1utf32ne__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf32ne__string__view__grapheme.html">utf32ne_string_view_grapheme</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__grapheme.html" title="Represents a single grapheme cluster. ">basic_grapheme</a> of <a class="el" href="classu5e_1_1utf32ne__string__view.html" title="Typedef: basic_encodedstring of utf32ne and basic_string_view&lt;int&gt; ">utf32ne_string_view</a>.  <a href="classu5e_1_1utf32ne__string__view__grapheme.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf32ne__string__view__grapheme__iterator.html">utf32ne_string_view_grapheme_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__grapheme__iterator.html" title="Iterator that describes full graphemes. ">basic_grapheme_iterator</a> of <a class="el" href="classu5e_1_1utf32ne__string__view.html" title="Typedef: basic_encodedstring of utf32ne and basic_string_view&lt;int&gt; ">utf32ne_string_view</a>.  <a href="classu5e_1_1utf32ne__string__view__grapheme__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8.html">utf8</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encoding type for UTF8 text. Unlike UTF16 and UTF32, UTF8 is endian independent.  <a href="classu5e_1_1utf8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__bounds.html">utf8_bounds</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check and enforce bounds of <a class="el" href="classu5e_1_1utf8.html" title="Encoding type for UTF8 text. Unlike UTF16 and UTF32, UTF8 is endian independent. ">utf8</a> text.  <a href="classu5e_1_1utf8__bounds.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__const__iterator.html">utf8_const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">const iterator for <a class="el" href="classu5e_1_1utf8.html" title="Encoding type for UTF8 text. Unlike UTF16 and UTF32, UTF8 is endian independent. ">utf8</a> encoded strings.  <a href="classu5e_1_1utf8__const__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__iterator.html">utf8_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutable <a class="el" href="classu5e_1_1utf8.html" title="Encoding type for UTF8 text. Unlike UTF16 and UTF32, UTF8 is endian independent. ">utf8</a> iterator  <a href="classu5e_1_1utf8__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__iterator__base.html">utf8_iterator_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the basic inner workings of <a class="el" href="classu5e_1_1utf8.html" title="Encoding type for UTF8 text. Unlike UTF16 and UTF32, UTF8 is endian independent. ">utf8</a> iterator.  <a href="classu5e_1_1utf8__iterator__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__string.html">utf8_string</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__encodedstring.html" title="basic encoding support over string-like objects. ">basic_encodedstring</a> of <a class="el" href="classu5e_1_1utf8.html" title="Encoding type for UTF8 text. Unlike UTF16 and UTF32, UTF8 is endian independent. ">utf8</a> and std::string.  <a href="classu5e_1_1utf8__string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__string__grapheme.html">utf8_string_grapheme</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__grapheme.html" title="Represents a single grapheme cluster. ">basic_grapheme</a> of <a class="el" href="classu5e_1_1utf8__string.html" title="Typedef: basic_encodedstring of utf8 and std::string. ">utf8_string</a>.  <a href="classu5e_1_1utf8__string__grapheme.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__string__grapheme__iterator.html">utf8_string_grapheme_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__grapheme__iterator.html" title="Iterator that describes full graphemes. ">basic_grapheme_iterator</a> of <a class="el" href="classu5e_1_1utf8__string.html" title="Typedef: basic_encodedstring of utf8 and std::string. ">utf8_string</a>.  <a href="classu5e_1_1utf8__string__grapheme__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__string__view.html">utf8_string_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__encodedstring.html" title="basic encoding support over string-like objects. ">basic_encodedstring</a> of <a class="el" href="classu5e_1_1utf8.html" title="Encoding type for UTF8 text. Unlike UTF16 and UTF32, UTF8 is endian independent. ">utf8</a> and string_view.  <a href="classu5e_1_1utf8__string__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__string__view__grapheme.html">utf8_string_view_grapheme</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__grapheme.html" title="Represents a single grapheme cluster. ">basic_grapheme</a> of <a class="el" href="classu5e_1_1utf8__string__view.html" title="Typedef: basic_encodedstring of utf8 and string_view. ">utf8_string_view</a>.  <a href="classu5e_1_1utf8__string__view__grapheme.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__string__view__grapheme__iterator.html">utf8_string_view_grapheme_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef: <a class="el" href="classu5e_1_1basic__grapheme__iterator.html" title="Iterator that describes full graphemes. ">basic_grapheme_iterator</a> of <a class="el" href="classu5e_1_1utf8__string__view.html" title="Typedef: basic_encodedstring of utf8 and string_view. ">utf8_string_view</a>.  <a href="classu5e_1_1utf8__string__view__grapheme__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classu5e_1_1utf8__util.html">utf8_util</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic operations necessary for implementing <a class="el" href="classu5e_1_1utf8.html" title="Encoding type for UTF8 text. Unlike UTF16 and UTF32, UTF8 is endian independent. ">utf8</a>.  <a href="classu5e_1_1utf8__util.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a141e060d3ece7c1ebc6950dd73e30d8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a141e060d3ece7c1ebc6950dd73e30d8a"></a>
typedef <a class="el" href="classu5e_1_1basic__encodedstring.html">basic_encodedstring</a>&lt; <a class="el" href="classu5e_1_1utf32ne.html">utf32ne</a>, std::basic_string&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a141e060d3ece7c1ebc6950dd73e30d8a">utf32ne_string</a></td></tr>
<tr class="memdesc:a141e060d3ece7c1ebc6950dd73e30d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__encodedstring.html" title="basic encoding support over string-like objects. ">basic_encodedstring</a> of <a class="el" href="classu5e_1_1utf32ne.html" title="Architecture-specific type to interface UTF32BE or UTF32LE. ">utf32ne</a> and std::basic_string&lt;int&gt; <br /></td></tr>
<tr class="separator:a141e060d3ece7c1ebc6950dd73e30d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02b618a332250bdd04e7f406b1d62ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac02b618a332250bdd04e7f406b1d62ca"></a>
typedef <a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; <a class="el" href="classu5e_1_1utf32ne__string.html">utf32ne_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#ac02b618a332250bdd04e7f406b1d62ca">utf32ne_string_grapheme</a></td></tr>
<tr class="memdesc:ac02b618a332250bdd04e7f406b1d62ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__grapheme.html" title="Represents a single grapheme cluster. ">basic_grapheme</a> of <a class="el" href="classu5e_1_1utf32ne__string.html" title="Typedef: basic_encodedstring of utf32ne and std::basic_string&lt;int&gt; ">utf32ne_string</a>. <br /></td></tr>
<tr class="separator:ac02b618a332250bdd04e7f406b1d62ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6a21f39fe61b5f0188961809bb6eaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec6a21f39fe61b5f0188961809bb6eaa"></a>
typedef <a class="el" href="classu5e_1_1basic__grapheme__iterator.html">basic_grapheme_iterator</a>&lt; <a class="el" href="classu5e_1_1utf32ne__string.html">utf32ne_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#aec6a21f39fe61b5f0188961809bb6eaa">utf32ne_string_grapheme_iterator</a></td></tr>
<tr class="memdesc:aec6a21f39fe61b5f0188961809bb6eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__grapheme__iterator.html" title="Iterator that describes full graphemes. ">basic_grapheme_iterator</a> of <a class="el" href="classu5e_1_1utf32ne__string.html" title="Typedef: basic_encodedstring of utf32ne and std::basic_string&lt;int&gt; ">utf32ne_string</a>. <br /></td></tr>
<tr class="separator:aec6a21f39fe61b5f0188961809bb6eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe53515f1f5ae975fb85538bab13351"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fe53515f1f5ae975fb85538bab13351"></a>
typedef <a class="el" href="classu5e_1_1basic__encodedstring.html">basic_encodedstring</a>&lt; <a class="el" href="classu5e_1_1utf32ne.html">u5e::utf32ne</a>, std::experimental::basic_string_view&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a2fe53515f1f5ae975fb85538bab13351">utf32ne_string_view</a></td></tr>
<tr class="memdesc:a2fe53515f1f5ae975fb85538bab13351"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__encodedstring.html" title="basic encoding support over string-like objects. ">basic_encodedstring</a> of <a class="el" href="classu5e_1_1utf32ne.html" title="Architecture-specific type to interface UTF32BE or UTF32LE. ">utf32ne</a> and basic_string_view&lt;int&gt; <br /></td></tr>
<tr class="separator:a2fe53515f1f5ae975fb85538bab13351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1e65e4fe686226fe42d1b2eca47692"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f1e65e4fe686226fe42d1b2eca47692"></a>
typedef <a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; <a class="el" href="classu5e_1_1utf32ne__string__view.html">utf32ne_string_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a4f1e65e4fe686226fe42d1b2eca47692">utf32ne_string_view_grapheme</a></td></tr>
<tr class="memdesc:a4f1e65e4fe686226fe42d1b2eca47692"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__grapheme.html" title="Represents a single grapheme cluster. ">basic_grapheme</a> of <a class="el" href="classu5e_1_1utf32ne__string__view.html" title="Typedef: basic_encodedstring of utf32ne and basic_string_view&lt;int&gt; ">utf32ne_string_view</a>. <br /></td></tr>
<tr class="separator:a4f1e65e4fe686226fe42d1b2eca47692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf56226d046da2bbabafc29c5509c27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bf56226d046da2bbabafc29c5509c27"></a>
typedef <a class="el" href="classu5e_1_1basic__grapheme__iterator.html">basic_grapheme_iterator</a>&lt; <a class="el" href="classu5e_1_1utf32ne__string__view.html">utf32ne_string_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a8bf56226d046da2bbabafc29c5509c27">utf32ne_string_view_grapheme_iterator</a></td></tr>
<tr class="memdesc:a8bf56226d046da2bbabafc29c5509c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__grapheme__iterator.html" title="Iterator that describes full graphemes. ">basic_grapheme_iterator</a> of <a class="el" href="classu5e_1_1utf32ne__string__view.html" title="Typedef: basic_encodedstring of utf32ne and basic_string_view&lt;int&gt; ">utf32ne_string_view</a>. <br /></td></tr>
<tr class="separator:a8bf56226d046da2bbabafc29c5509c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3814526c6ea7ca04223a8ec1b662d497"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3814526c6ea7ca04223a8ec1b662d497"></a>
typedef <a class="el" href="classu5e_1_1basic__encodedstring.html">basic_encodedstring</a>&lt; <a class="el" href="classu5e_1_1utf8.html">utf8</a>, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a3814526c6ea7ca04223a8ec1b662d497">utf8_string</a></td></tr>
<tr class="memdesc:a3814526c6ea7ca04223a8ec1b662d497"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__encodedstring.html" title="basic encoding support over string-like objects. ">basic_encodedstring</a> of <a class="el" href="classu5e_1_1utf8.html" title="Encoding type for UTF8 text. Unlike UTF16 and UTF32, UTF8 is endian independent. ">utf8</a> and std::string. <br /></td></tr>
<tr class="separator:a3814526c6ea7ca04223a8ec1b662d497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1326ad571e74e2be8a723612b8e29526"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1326ad571e74e2be8a723612b8e29526"></a>
typedef <a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; <a class="el" href="classu5e_1_1utf8__string.html">utf8_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a1326ad571e74e2be8a723612b8e29526">utf8_string_grapheme</a></td></tr>
<tr class="memdesc:a1326ad571e74e2be8a723612b8e29526"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__grapheme.html" title="Represents a single grapheme cluster. ">basic_grapheme</a> of <a class="el" href="classu5e_1_1utf8__string.html" title="Typedef: basic_encodedstring of utf8 and std::string. ">utf8_string</a>. <br /></td></tr>
<tr class="separator:a1326ad571e74e2be8a723612b8e29526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a084fc31e6af27114007a21f6f89e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a084fc31e6af27114007a21f6f89e7"></a>
typedef <a class="el" href="classu5e_1_1basic__grapheme__iterator.html">basic_grapheme_iterator</a>&lt; <a class="el" href="classu5e_1_1utf8__string.html">utf8_string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a74a084fc31e6af27114007a21f6f89e7">utf8_string_grapheme_iterator</a></td></tr>
<tr class="memdesc:a74a084fc31e6af27114007a21f6f89e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__grapheme__iterator.html" title="Iterator that describes full graphemes. ">basic_grapheme_iterator</a> of <a class="el" href="classu5e_1_1utf8__string.html" title="Typedef: basic_encodedstring of utf8 and std::string. ">utf8_string</a>. <br /></td></tr>
<tr class="separator:a74a084fc31e6af27114007a21f6f89e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5abb9026a8b93e2aadd01ee514208d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5abb9026a8b93e2aadd01ee514208d3"></a>
typedef <a class="el" href="classu5e_1_1basic__encodedstring.html">basic_encodedstring</a>&lt; <a class="el" href="classu5e_1_1utf8.html">utf8</a>, std::experimental::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#af5abb9026a8b93e2aadd01ee514208d3">utf8_string_view</a></td></tr>
<tr class="memdesc:af5abb9026a8b93e2aadd01ee514208d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__encodedstring.html" title="basic encoding support over string-like objects. ">basic_encodedstring</a> of <a class="el" href="classu5e_1_1utf8.html" title="Encoding type for UTF8 text. Unlike UTF16 and UTF32, UTF8 is endian independent. ">utf8</a> and string_view. <br /></td></tr>
<tr class="separator:af5abb9026a8b93e2aadd01ee514208d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3255333e6ec6b7d9fd55a3937b445a9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3255333e6ec6b7d9fd55a3937b445a9e"></a>
typedef <a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; <a class="el" href="classu5e_1_1utf8__string__view.html">utf8_string_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a3255333e6ec6b7d9fd55a3937b445a9e">utf8_string_view_grapheme</a></td></tr>
<tr class="memdesc:a3255333e6ec6b7d9fd55a3937b445a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__grapheme.html" title="Represents a single grapheme cluster. ">basic_grapheme</a> of <a class="el" href="classu5e_1_1utf8__string__view.html" title="Typedef: basic_encodedstring of utf8 and string_view. ">utf8_string_view</a>. <br /></td></tr>
<tr class="separator:a3255333e6ec6b7d9fd55a3937b445a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e36b87941b75a409fff1cae69b5bdb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e36b87941b75a409fff1cae69b5bdb0"></a>
typedef <a class="el" href="classu5e_1_1basic__grapheme__iterator.html">basic_grapheme_iterator</a>&lt; <a class="el" href="classu5e_1_1utf8__string__view.html">utf8_string_view</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a3e36b87941b75a409fff1cae69b5bdb0">utf8_string_view_grapheme_iterator</a></td></tr>
<tr class="memdesc:a3e36b87941b75a409fff1cae69b5bdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classu5e_1_1basic__grapheme__iterator.html" title="Iterator that describes full graphemes. ">basic_grapheme_iterator</a> of <a class="el" href="classu5e_1_1utf8__string__view.html" title="Typedef: basic_encodedstring of utf8 and string_view. ">utf8_string_view</a>. <br /></td></tr>
<tr class="separator:a3e36b87941b75a409fff1cae69b5bdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab073e1177dd43954214d53300c11878b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#ab073e1177dd43954214d53300c11878b">canonical_combining_order</a> (int a, int b)</td></tr>
<tr class="memdesc:ab073e1177dd43954214d53300c11878b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare codepoints according to the canonical combining order  <a href="#ab073e1177dd43954214d53300c11878b">More...</a><br /></td></tr>
<tr class="separator:ab073e1177dd43954214d53300c11878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d3271854e997cb3cc056ccfb6b2530"><td class="memTemplParams" colspan="2">template&lt;typename StorageType &gt; </td></tr>
<tr class="memitem:a81d3271854e997cb3cc056ccfb6b2530"><td class="memTemplItemLeft" align="right" valign="top">StorageType::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a81d3271854e997cb3cc056ccfb6b2530">canonical_composition</a> (StorageType &amp;data, int *count)</td></tr>
<tr class="memdesc:a81d3271854e997cb3cc056ccfb6b2530"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs in-place canonical composition.  <a href="#a81d3271854e997cb3cc056ccfb6b2530">More...</a><br /></td></tr>
<tr class="separator:a81d3271854e997cb3cc056ccfb6b2530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73102e631813a8d4cafd7644de4b294a"><td class="memTemplParams" colspan="2">template&lt;typename OutputStringType &gt; </td></tr>
<tr class="memitem:a73102e631813a8d4cafd7644de4b294a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a73102e631813a8d4cafd7644de4b294a">canonical_decomposition</a> (const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> input, OutputStringType &amp;output)</td></tr>
<tr class="memdesc:a73102e631813a8d4cafd7644de4b294a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform codepoint-by-codepoint canonical decomposition.  <a href="#a73102e631813a8d4cafd7644de4b294a">More...</a><br /></td></tr>
<tr class="separator:a73102e631813a8d4cafd7644de4b294a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0975ab03c565571b3a521643b4fc86"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#aae0975ab03c565571b3a521643b4fc86">operator==</a> (const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> &amp;a, const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> &amp;b)</td></tr>
<tr class="separator:aae0975ab03c565571b3a521643b4fc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2040b81793be0aa54a2950cc7c6d580c"><td class="memTemplParams" colspan="2">template&lt;typename PropResolver , typename OutputStringType &gt; </td></tr>
<tr class="memitem:a2040b81793be0aa54a2950cc7c6d580c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a2040b81793be0aa54a2950cc7c6d580c">codepoint_decomposition</a> (const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> input, OutputStringType &amp;output, PropResolver &amp;resolver)</td></tr>
<tr class="memdesc:a2040b81793be0aa54a2950cc7c6d580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform codepoint by codepoint decomposition.  <a href="#a2040b81793be0aa54a2950cc7c6d580c">More...</a><br /></td></tr>
<tr class="separator:a2040b81793be0aa54a2950cc7c6d580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9059503811c633a952b1b52eab08c75"><td class="memTemplParams" colspan="2">template&lt;typename OutputStringType &gt; </td></tr>
<tr class="memitem:ab9059503811c633a952b1b52eab08c75"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#ab9059503811c633a952b1b52eab08c75">compatibility_and_canonical_decomposition</a> (const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> input, OutputStringType &amp;output)</td></tr>
<tr class="memdesc:ab9059503811c633a952b1b52eab08c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform compatibility and canonical decomposition.  <a href="#ab9059503811c633a952b1b52eab08c75">More...</a><br /></td></tr>
<tr class="separator:ab9059503811c633a952b1b52eab08c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300b77046593bf5484867461ac65cb88"><td class="memTemplParams" colspan="2">template&lt;typename InputIteratorType , typename OutputType , typename Functor &gt; </td></tr>
<tr class="memitem:a300b77046593bf5484867461ac65cb88"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88">filter</a> (InputIteratorType input_from, InputIteratorType input_to, OutputType &amp;output, Functor operation)</td></tr>
<tr class="memdesc:a300b77046593bf5484867461ac65cb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walks an input iterator through a filter.  <a href="#a300b77046593bf5484867461ac65cb88">More...</a><br /></td></tr>
<tr class="separator:a300b77046593bf5484867461ac65cb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683f83d363d3e0fbfa6417e4b4b44123"><td class="memTemplParams" colspan="2">template&lt;typename InputStorageType , typename OutputStorageType  = InputStorageType&gt; </td></tr>
<tr class="memitem:a683f83d363d3e0fbfa6417e4b4b44123"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a683f83d363d3e0fbfa6417e4b4b44123">normalization_form_c</a> (<a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; InputStorageType &gt; grapheme, OutputStorageType &amp;output)</td></tr>
<tr class="memdesc:a683f83d363d3e0fbfa6417e4b4b44123"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a> algorithm for normalizing graphemes  <a href="#a683f83d363d3e0fbfa6417e4b4b44123">More...</a><br /></td></tr>
<tr class="separator:a683f83d363d3e0fbfa6417e4b4b44123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe914ecfbcbfd5630b6c38c696b868f"><td class="memTemplParams" colspan="2">template&lt;typename InputStorageType , typename OutputStorageType  = InputStorageType&gt; </td></tr>
<tr class="memitem:a1fe914ecfbcbfd5630b6c38c696b868f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a1fe914ecfbcbfd5630b6c38c696b868f">normalization_form_d</a> (<a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; InputStorageType &gt; grapheme, OutputStorageType &amp;output)</td></tr>
<tr class="memdesc:a1fe914ecfbcbfd5630b6c38c696b868f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a> algorithm for normalizing graphemes  <a href="#a1fe914ecfbcbfd5630b6c38c696b868f">More...</a><br /></td></tr>
<tr class="separator:a1fe914ecfbcbfd5630b6c38c696b868f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67caa33a03e9b645861525fcf447c845"><td class="memTemplParams" colspan="2">template&lt;typename InputStorageType , typename OutputStorageType  = InputStorageType&gt; </td></tr>
<tr class="memitem:a67caa33a03e9b645861525fcf447c845"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a67caa33a03e9b645861525fcf447c845">normalization_form_kc</a> (<a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; InputStorageType &gt; grapheme, OutputStorageType &amp;output)</td></tr>
<tr class="memdesc:a67caa33a03e9b645861525fcf447c845"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a> algorithm for normalizing graphemes  <a href="#a67caa33a03e9b645861525fcf447c845">More...</a><br /></td></tr>
<tr class="separator:a67caa33a03e9b645861525fcf447c845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fc11752025c4901b3fdb94f014af57"><td class="memTemplParams" colspan="2">template&lt;typename InputStorageType , typename OutputStorageType  = InputStorageType&gt; </td></tr>
<tr class="memitem:a27fc11752025c4901b3fdb94f014af57"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a27fc11752025c4901b3fdb94f014af57">normalization_form_kd</a> (<a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; InputStorageType &gt; grapheme, OutputStorageType &amp;output)</td></tr>
<tr class="memdesc:a27fc11752025c4901b3fdb94f014af57"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a> algorithm for normalizing graphemes  <a href="#a27fc11752025c4901b3fdb94f014af57">More...</a><br /></td></tr>
<tr class="separator:a27fc11752025c4901b3fdb94f014af57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4f3724ee30c4c3e163a382398980f713"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a4f3724ee30c4c3e163a382398980f713">operator==</a> (const <a class="el" href="classu5e_1_1codepoint__traits.html#a11f00d20915e28671519ef0c96fab05d">codepoint_traits::int_type</a> a, const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> &amp;b)</td></tr>
<tr class="separator:a4f3724ee30c4c3e163a382398980f713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c53ea83db2e4b2a6cc4c3bb281d438"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceu5e.html#a38c53ea83db2e4b2a6cc4c3bb281d438">operator==</a> (const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> &amp;a, const <a class="el" href="classu5e_1_1codepoint__traits.html#a11f00d20915e28671519ef0c96fab05d">codepoint_traits::int_type</a> b)</td></tr>
<tr class="separator:a38c53ea83db2e4b2a6cc4c3bb281d438"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>main <a class="el" href="namespaceu5e.html" title="main u5e namespace ">u5e</a> namespace </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab073e1177dd43954214d53300c11878b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool u5e::canonical_combining_order </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare codepoints according to the canonical combining order </p>
<p>This is intended to be used with std::sort on a <a class="el" href="classu5e_1_1utf32ne.html" title="Architecture-specific type to interface UTF32BE or UTF32LE. ">utf32ne</a> string type. </p>

<p>Definition at line <a class="el" href="canonical__combining__order_8hpp_source.html#l00013">13</a> of file <a class="el" href="canonical__combining__order_8hpp_source.html">canonical_combining_order.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81d3271854e997cb3cc056ccfb6b2530"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StorageType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StorageType::iterator u5e::canonical_composition </td>
          <td>(</td>
          <td class="paramtype">StorageType &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>performs in-place canonical composition. </p>
<p>This will return the iterator in the end position after the composition.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StorageType</td><td>the storage type where to apply it.</td></tr>
  </table>
  </dd>
</dl>
<p>Must support codepoint_begin, codepont_cbegin, codepoint_end, codepoint_cend, as well as the member types iterator and const_iterator. It is also a requirement that you should be able to write to it as you read it, which means that this must only be used in utf32 iterators, otherwise the output may race ahead of the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the object where the canonical composition will be performed.</td></tr>
    <tr><td class="paramname">count</td><td>return pointer for how many compositions were performed </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="canonical__composition_8hpp_source.html#l00029">29</a> of file <a class="el" href="canonical__composition_8hpp_source.html">canonical_composition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73102e631813a8d4cafd7644de4b294a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputStringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int u5e::canonical_decomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputStringType &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform codepoint-by-codepoint canonical decomposition. </p>
<p>This is one step of the normalization process, you probably want to use that instead.</p>
<p>This is meant to be used as an operation for <a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputStringType</td><td>the output string type to be used. Because this reads data from the database, the returned data is <a class="el" href="classu5e_1_1utf32ne.html" title="Architecture-specific type to interface UTF32BE or UTF32LE. ">utf32ne</a>, so you need an OutputStringType that is compatible with that. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="canonical__decomposition_8hpp_source.html#l00031">31</a> of file <a class="el" href="canonical__decomposition_8hpp_source.html">canonical_decomposition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2040b81793be0aa54a2950cc7c6d580c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropResolver , typename OutputStringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int u5e::codepoint_decomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputStringType &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PropResolver &amp;&#160;</td>
          <td class="paramname"><em>resolver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform codepoint by codepoint decomposition. </p>
<p>This is one step of the normalization process, you probably want to use that instead.</p>
<p>This implements only the logic of dealing with the resolved data, the actual database resolution is a template parameter.</p>
<p>This is meant to be used as an operation for <a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PropResolver</td><td>the function that resolves the input codepoint into a sequence of decomposed codepoints.</td></tr>
    <tr><td class="paramname">OutputStringType</td><td>the output string type to be used. Because this reads data from the database, the returned data is <a class="el" href="classu5e_1_1utf32ne.html" title="Architecture-specific type to interface UTF32BE or UTF32LE. ">utf32ne</a>, so you need an OutputStringType that is compatible with that. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="codepoint__decomposition_8hpp_source.html#l00036">36</a> of file <a class="el" href="codepoint__decomposition_8hpp_source.html">codepoint_decomposition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9059503811c633a952b1b52eab08c75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputStringType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int u5e::compatibility_and_canonical_decomposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a>&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputStringType &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform compatibility and canonical decomposition. </p>
<p>This is one step of the normalization process, you probably want to use that instead.</p>
<p>This is meant to be used as an operation for <a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputStringType</td><td>the output string type to be used. Because this reads data from the database, the returned data is <a class="el" href="classu5e_1_1utf32ne.html" title="Architecture-specific type to interface UTF32BE or UTF32LE. ">utf32ne</a>, so you need an OutputStringType that is compatible with that. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="compatibility__and__canonical__decomposition_8hpp_source.html#l00031">31</a> of file <a class="el" href="compatibility__and__canonical__decomposition_8hpp_source.html">compatibility_and_canonical_decomposition.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a300b77046593bf5484867461ac65cb88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIteratorType , typename OutputType , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int u5e::filter </td>
          <td>(</td>
          <td class="paramtype">InputIteratorType&#160;</td>
          <td class="paramname"><em>input_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIteratorType&#160;</td>
          <td class="paramname"><em>input_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walks an input iterator through a filter. </p>
<p>This will go from the begin to the end of the input iterator and will execute the filter function once for every input element.</p>
<p>Unlike std::transform, the filter function does not return the output element, but it receives the output object and will do whatever makes sense with the output object.</p>
<p>That means that the type of filter will define what type of object can be used as output. The filter function itself will not touch the output object, but simply forward it to the operator function.</p>
<p>The operator function returns an int that is meant to indicate how much output was produced. The filter function will accumulate those values and return the sum.</p>
<p>The filter is not required to produce a constant number of outputs for each input. The function can be produce many outputs or even none at all during the processing of each element.</p>
<p>The value type for input and output is not required to be the same. The input type is resolved by the value_type member type of the input iterator type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIteratorType</td><td>the type of the input iterator </td></tr>
    <tr><td class="paramname">OutputType</td><td>the type of the output iterator </td></tr>
    <tr><td class="paramname">Functor</td><td>the callback function type called for each element</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_from</td><td>starting position for the input iterator </td></tr>
    <tr><td class="paramname">input_to</td><td>end position for the input iterator </td></tr>
    <tr><td class="paramname">output</td><td>output container sent to the operator function </td></tr>
    <tr><td class="paramname">operation</td><td>function that takes the element, the output container and returns the number of outputted elements </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="filter_8hpp_source.html#l00046">46</a> of file <a class="el" href="filter_8hpp_source.html">filter.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a683f83d363d3e0fbfa6417e4b4b44123"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputStorageType , typename OutputStorageType  = InputStorageType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int u5e::normalization_form_c </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; InputStorageType &gt;&#160;</td>
          <td class="paramname"><em>grapheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputStorageType &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a> algorithm for normalizing graphemes </p>
<p>This will work by reading an input grapheme iterator and, grapheme by grapheme normalize them in form C.</p>
<p>This will use the unicode database to search for equivalent codepoint sequences. </p>

<p>Definition at line <a class="el" href="normalization__form__c_8hpp_source.html#l00024">24</a> of file <a class="el" href="normalization__form__c_8hpp_source.html">normalization_form_c.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1fe914ecfbcbfd5630b6c38c696b868f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputStorageType , typename OutputStorageType  = InputStorageType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int u5e::normalization_form_d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; InputStorageType &gt;&#160;</td>
          <td class="paramname"><em>grapheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputStorageType &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a> algorithm for normalizing graphemes </p>
<p>This will work by reading an input grapheme iterator and, grapheme by grapheme normalize them in form D.</p>
<p>This will use the unicode database to search for equivalent codepoint sequences. </p>

<p>Definition at line <a class="el" href="normalization__form__d_8hpp_source.html#l00023">23</a> of file <a class="el" href="normalization__form__d_8hpp_source.html">normalization_form_d.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67caa33a03e9b645861525fcf447c845"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputStorageType , typename OutputStorageType  = InputStorageType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int u5e::normalization_form_kc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; InputStorageType &gt;&#160;</td>
          <td class="paramname"><em>grapheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputStorageType &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a> algorithm for normalizing graphemes </p>
<p>This will work by reading an input grapheme iterator and, grapheme by grapheme normalize them in form KC.</p>
<p>This will use the unicode database to search for equivalent codepoint sequences. </p>

<p>Definition at line <a class="el" href="normalization__form__kc_8hpp_source.html#l00024">24</a> of file <a class="el" href="normalization__form__kc_8hpp_source.html">normalization_form_kc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27fc11752025c4901b3fdb94f014af57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputStorageType , typename OutputStorageType  = InputStorageType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int u5e::normalization_form_kd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classu5e_1_1basic__grapheme.html">basic_grapheme</a>&lt; InputStorageType &gt;&#160;</td>
          <td class="paramname"><em>grapheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputStorageType &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="namespaceu5e.html#a300b77046593bf5484867461ac65cb88" title="Walks an input iterator through a filter. ">u5e::filter</a> algorithm for normalizing graphemes </p>
<p>This will work by reading an input grapheme iterator and, grapheme by grapheme normalize them in form KD.</p>
<p>This will use the unicode database to search for equivalent codepoint sequences. </p>

<p>Definition at line <a class="el" href="normalization__form__kd_8hpp_source.html#l00023">23</a> of file <a class="el" href="normalization__form__kd_8hpp_source.html">normalization_form_kd.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aae0975ab03c565571b3a521643b4fc86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool u5e::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two codepoints by comparing their values. </p>

<p>Definition at line <a class="el" href="codepoint_8hpp_source.html#l00056">56</a> of file <a class="el" href="codepoint_8hpp_source.html">codepoint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f3724ee30c4c3e163a382398980f713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool u5e::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classu5e_1_1codepoint__traits.html#a11f00d20915e28671519ef0c96fab05d">codepoint_traits::int_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare an int to a codepoint by comparing the codepoint's value with the integer. </p>

<p>Definition at line <a class="el" href="codepoint_8hpp_source.html#l00063">63</a> of file <a class="el" href="codepoint_8hpp_source.html">codepoint.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38c53ea83db2e4b2a6cc4c3bb281d438"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool u5e::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classu5e_1_1codepoint.html">codepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classu5e_1_1codepoint__traits.html#a11f00d20915e28671519ef0c96fab05d">codepoint_traits::int_type</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare an int to a codepoint by comparing the codepoint's value with the integer. </p>

<p>Definition at line <a class="el" href="codepoint_8hpp_source.html#l00064">64</a> of file <a class="el" href="codepoint_8hpp_source.html">codepoint.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
